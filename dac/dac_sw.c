/*
 * This file is part of the libopencm3 project.
 *
 * Copyright (C) 2013 Karl Palsson <karlp@tweak.net.au>
 *
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <libopencm3/cm3/nvic.h>
#include <libopencm3/stm32/dac.h>
#include <libopencm3/stm32/gpio.h>
#include <libopencm3/stm32/rcc.h>

static void clock_setup(void)
{
    rcc_clock_setup_in_hse_16mhz_out_72mhz();
    /* Enable clock for DAC*/
    rcc_periph_clock_enable(RCC_DAC);
}

static void dac_setup(void)
{
    gpio_set_mode(GPIOA, GPIO_MODE_OUTPUT_50_MHZ, GPIO_CNF_OUTPUT_ALTFN_PUSHPULL, GPIO5);
    dac_disable(CHANNEL_2);
    dac_disable_waveform_generation(CHANNEL_2);
    dac_enable(CHANNEL_2);
    dac_set_trigger_source(DAC_CR_TSEL2_SW);
}

int main(void)
{
    clock_setup();
    dac_setup();
    // gpio_set_mode(GPIOD, GPIO_MODE_OUTPUT_2_MHZ,
    //               GPIO_CNF_OUTPUT_PUSHPULL, GPIO2);

    const uint8_t lut[256] = {
        0x7F, 0x82, 0x85, 0x88, 0x8B, 0x8F, 0x92, 0x95, 0x98, 0x9B,
        0x9E, 0xA1, 0xA4, 0xA7, 0xAA, 0xAD, 0xB0, 0xB2, 0xB5, 0xB8,
        0xBB, 0xBE, 0xC0, 0xC3, 0xC6, 0xC8, 0xCB, 0xCD, 0xD0, 0xD2,
        0xD4, 0xD7, 0xD9, 0xDB, 0xDD, 0xDF, 0xE1, 0xE3, 0xE5, 0xE7,
        0xE9, 0xEA, 0xEC, 0xEE, 0xEF, 0xF0, 0xF2, 0xF3, 0xF4, 0xF5,
        0xF7, 0xF8, 0xF9, 0xF9, 0xFA, 0xFB, 0xFC, 0xFC, 0xFD, 0xFD,
        0xFD, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFD, 0xFD,
        0xFD, 0xFC, 0xFC, 0xFB, 0xFA, 0xF9, 0xF9, 0xF8, 0xF7, 0xF5,
        0xF4, 0xF3, 0xF2, 0xF0, 0xEF, 0xEE, 0xEC, 0xEA, 0xE9, 0xE7,
        0xE5, 0xE3, 0xE1, 0xDF, 0xDD, 0xDB, 0xD9, 0xD7, 0xD4, 0xD2,
        0xD0, 0xCD, 0xCB, 0xC8, 0xC6, 0xC3, 0xC0, 0xBE, 0xBB, 0xB8,
        0xB5, 0xB2, 0xB0, 0xAD, 0xAA, 0xA7, 0xA4, 0xA1, 0x9E, 0x9B,
        0x98, 0x95, 0x92, 0x8F, 0x8B, 0x88, 0x85, 0x82, 0x7F, 0x7C,
        0x79, 0x76, 0x73, 0x6F, 0x6C, 0x69, 0x66, 0x63, 0x60, 0x5D,
        0x5A, 0x57, 0x54, 0x51, 0x4E, 0x4C, 0x49, 0x46, 0x43, 0x40,
        0x3E, 0x3B, 0x38, 0x36, 0x33, 0x31, 0x2E, 0x2C, 0x2A, 0x27,
        0x25, 0x23, 0x21, 0x1F, 0x1D, 0x1B, 0x19, 0x17, 0x15, 0x14,
        0x12, 0x10, 0x0F, 0x0E, 0x0C, 0x0B, 0x0A, 0x09, 0x07, 0x06,
        0x05, 0x05, 0x04, 0x03, 0x02, 0x02, 0x01, 0x01, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x02,
        0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x09, 0x0A, 0x0B,
        0x0C, 0x0E, 0x0F, 0x10, 0x12, 0x14, 0x15, 0x17, 0x19, 0x1B,
        0x1D, 0x1F, 0x21, 0x23, 0x25, 0x27, 0x2A, 0x2C, 0x2E, 0x31,
        0x33, 0x36, 0x38, 0x3B, 0x3E, 0x40, 0x43, 0x46, 0x49, 0x4C,
        0x4E, 0x51, 0x54, 0x57, 0x5A, 0x5D, 0x60, 0x63, 0x66, 0x69,
        0x6C, 0x6F, 0x73, 0x76, 0x79, 0x7C};

    while (1)
    {
        for (int j = 0; j < 256; j++)
        {
            dac_load_data_buffer_single(lut[j], RIGHT8, CHANNEL_2);
            dac_software_trigger(CHANNEL_2);
            // for (int i = 0; i < 10; i++) /* Wait a bit. */
            //     __asm__("NOP");
        }
    }

    // gpio_toggle(GPIOD, GPIO2);        /* LED on/off */

    return 0;
}